<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Midwest METAR + Wind + Alerts (Apr 2018)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="./vendor/leaflet/leaflet.css"/>
<script src="./vendor/leaflet/leaflet.js"></script>

<link rel="stylesheet" href="./vendor/leaflet-velocity/leaflet-velocity.min.css">
<script src="./vendor/leaflet-velocity/leaflet-velocity.min.js"></script>

<!-- MarkerCluster (CDN) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<style>
  html, body { height:100%; margin:0; }
  #map { height:100%; background:#fff; }

  .panel{
    position:absolute; top:10px; left:10px; z-index:9999;
    background:rgba(255,255,255,0.95);
    border:1px solid #ccc; border-radius:12px;
    padding:10px;
    font:600 12px/1.2 Arial, sans-serif;
    box-shadow: 0 2px 10px rgba(0,0,0,.10);
    min-width: 250px;
  }
  .row{ display:flex; gap:8px; align-items:center; margin-top:8px; }
  .btn{
    border:1px solid #333; background:#fff; border-radius:10px;
    padding:6px 10px; cursor:pointer; font:700 12px Arial;
  }
  .btn:active{ transform: translateY(1px); }
  .mono{ font-family: ui-monospace, Menlo, Consolas, monospace; font-weight:800; }

  .metar-dot{
    width:28px;height:28px;border-radius:50%;
    border:2px solid #333;
    display:flex;align-items:center;justify-content:center;
    font:800 12px/1 Arial, sans-serif;color:#111;
    box-shadow: 0 1px 3px rgba(0,0,0,.25);
  }
</style>
</head>

<body>
<div id="map"></div>

<div class="panel">
  <div style="font-size:13px;margin-bottom:6px">Apr 14, 2018 Case Study</div>

  <div class="row">
    <button class="btn" id="backBtn">◀ Back</button>
    <div class="mono" id="timeLabel">2018-04-14 16Z</div>
    <button class="btn" id="fwdBtn">Forward ▶</button>
  </div>

  <div class="row">
    <span style="opacity:.75">METAR step:</span>
    <span class="mono">3 hours</span>
  </div>

  <div class="row">
    <span style="opacity:.75" id="status">Loading…</span>
  </div>
</div>

<script>
  // -----------------------------
  // Map
  // -----------------------------
  const map = L.map("map", { zoomControl:true }).setView([44.2, -96.5], 6);

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "© OpenStreetMap contributors"
  }).addTo(map);
  map.attributionControl.setPrefix(false);

  const statusEl = document.getElementById("status");
  const timeLabelEl = document.getElementById("timeLabel");

  // -----------------------------
  // Time controls
  // -----------------------------
  let current = new Date(Date.UTC(2018, 3, 14, 16, 0, 0)); // 2018-04-14 16Z
  const stepHours = 3;

  function fmtZ(d){
    const Y = d.getUTCFullYear();
    const M = String(d.getUTCMonth()+1).padStart(2,"0");
    const D = String(d.getUTCDate()).padStart(2,"0");
    const H = String(d.getUTCHours()).padStart(2,"0");
    return `${Y}-${M}-${D} ${H}Z`;
  }
  function toISOZ(d){
    const Y = d.getUTCFullYear();
    const M = String(d.getUTCMonth()+1).padStart(2,"0");
    const D = String(d.getUTCDate()).padStart(2,"0");
    const H = String(d.getUTCHours()).padStart(2,"0");
    return `${Y}-${M}-${D}T${H}:00:00Z`;
  }
  function updateTimeLabel(){ timeLabelEl.textContent = fmtZ(current); }
  updateTimeLabel();

  document.getElementById("backBtn").onclick = async () => {
    current = new Date(current.getTime() - stepHours*3600*1000);
    updateTimeLabel();
    await refreshMetars();
  };
  document.getElementById("fwdBtn").onclick = async () => {
    current = new Date(current.getTime() + stepHours*3600*1000);
    updateTimeLabel();
    await refreshMetars();
  };

  // -----------------------------
  // Cluster groups (one per layer)
  // -----------------------------
  function makeCluster(){
    return L.markerClusterGroup({
      showCoverageOnHover: false,
      spiderfyOnMaxZoom: true,
      disableClusteringAtZoom: 8,  // key: zoom in -> all points appear
      maxClusterRadius: 55
    });
  }

  const tempCluster = makeCluster().addTo(map);
  const dewCluster  = makeCluster();
  const windCluster = makeCluster();
  const gustCluster = makeCluster();
  const visCluster  = makeCluster();
  const presCluster = makeCluster();
  const wxCluster   = makeCluster();

  // Particles & Alerts placeholders
  let particlesLayer = null;
  const alertsLayer = L.geoJSON(null, {
    style: { weight: 2, color: "#cc0000", fillOpacity: 0.05 }
  });

  const layerControl = L.control.layers(
    { "OpenStreetMap": osm },
    {
      "Temperature (°F)": tempCluster,
      "Dew Point (°F)": dewCluster,
      "Wind (mph)": windCluster,
      "Wind Gusts (mph)": gustCluster,
      "Visibility (mi)": visCluster,
      "Pressure (trend)": presCluster,
      "Weather Codes": wxCluster,
      "Alerts (WWA)": alertsLayer
      // "Wind particles" added after load
    },
    { collapsed:false }
  ).addTo(map);

  // -----------------------------
  // Color ramps
  // -----------------------------
  function piecewiseColor(x, stops){
    if (x == null || !Number.isFinite(x)) return "rgb(255,255,255)";
    if (x <= stops[0].v) return `rgb(${stops[0].c.join(",")})`;
    if (x >= stops[stops.length-1].v) return `rgb(${stops[stops.length-1].c.join(",")})`;
    for (let i=0; i<stops.length-1; i++){
      const a = stops[i], b = stops[i+1];
      if (x >= a.v && x <= b.v){
        const k = (x - a.v) / (b.v - a.v);
        const r = Math.round(a.c[0] + (b.c[0]-a.c[0])*k);
        const g = Math.round(a.c[1] + (b.c[1]-a.c[1])*k);
        const bb= Math.round(a.c[2] + (b.c[2]-a.c[2])*k);
        return `rgb(${r},${g},${bb})`;
      }
    }
    return "rgb(255,255,255)";
  }

  function tempColorF(t){
    return piecewiseColor(t, [
      {v: 10, c: [170, 220, 255]},
      {v: 20, c: [120, 190, 255]},
      {v: 30, c: [0, 70, 200]},
      {v: 40, c: [0, 170, 0]},
      {v: 50, c: [150, 255, 150]},
      {v: 60, c: [255, 235, 0]},
      {v: 70, c: [255, 140, 0]},
      {v: 85, c: [255, 80, 0]}
    ]);
  }

  function dewColorF(td){
    return piecewiseColor(td, [
      {v: 10, c: [90, 55, 20]},
      {v: 20, c: [140, 95, 40]},
      {v: 30, c: [200, 160, 110]},
      {v: 50, c: [190, 200, 140]},
      {v: 60, c: [0, 170, 0]},
      {v: 70, c: [0, 90, 0]}
    ]);
  }

  function windColorMph(spd){
    return piecewiseColor(spd, [
      {v: 0,  c: [0, 40, 160]},
      {v: 10, c: [0, 120, 255]},
      {v: 20, c: [0, 210, 180]},
      {v: 35, c: [255, 220, 0]},
      {v: 50, c: [255, 120, 0]},
      {v: 70, c: [255, 80, 0]}
    ]);
  }

  function pressureTrendColor(deltaInHg){
    // delta = current - prev
    if (deltaInHg == null || !Number.isFinite(deltaInHg)) return "rgb(235,235,235)";
    if (deltaInHg > 0.02) return "rgb(0,170,0)";     // rising
    if (deltaInHg < -0.02) return "rgb(200,0,0)";    // falling
    return "rgb(200,200,200)";                       // steady
  }

  function dotIcon(txt, fill){
    return L.divIcon({
      className:"",
      html:`<div class="metar-dot" style="background:${fill}">${txt}</div>`,
      iconSize:[28,28],
      iconAnchor:[14,14]
    });
  }

  // -----------------------------
  // METAR + trend fetch (T and T-3h)
  // -----------------------------
  const networks = ["SD_ASOS","MN_ASOS","IA_ASOS","NE_ASOS","ND_ASOS","WI_ASOS","IL_ASOS","MI_ASOS"];
  const reportType = 3;

  function metarURL(d){
    const iso = toISOZ(d);
    return "https://mesonet.agron.iastate.edu/cgi-bin/request/asos.py"
      + "?data=tmpf&data=dwpf&data=drct&data=sknt&data=gust&data=vsby&data=alti&data=wxcodes"
      + `&network=${encodeURIComponent(networks.join(","))}`
      + `&report_type=${reportType}`
      + "&latlon=yes&format=onlycomma&tz=UTC"
      + `&sts=${encodeURIComponent(iso)}`
      + `&ets=${encodeURIComponent(iso)}`
      + "&missing=empty";
  }

  function parseCSV(text){
    const lines = text.split(/\r?\n/).filter(l => l.trim() && !l.startsWith("#"));
    if (lines.length < 2) return [];
    const header = lines[0].split(",");
    return lines.slice(1).map(line => {
      const cols = line.split(",");
      const obj = {};
      header.forEach((h,i)=>obj[h]=cols[i] ?? "");
      return obj;
    });
  }
  function num(v){
    const s = (v ?? "").toString().trim();
    if (!s) return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }
  function ktToMph(kt){ return kt == null ? null : (kt * 1.15078); }

  function popupHTML(r, presDelta){
    const sknt = num(r.sknt);
    const gust = num(r.gust);
    const mph  = sknt != null ? Math.round(ktToMph(sknt)) : "—";
    const gmh  = gust != null ? Math.round(ktToMph(gust)) : "—";
    const dTxt = (presDelta == null) ? "—" : `${presDelta > 0 ? "+" : ""}${presDelta.toFixed(2)} in/3h`;
    return `
      <div style="font:600 13px/1.3 Arial,sans-serif">
        <div style="font-size:14px;margin-bottom:4px"><b>${r.station || "Station"}</b></div>
        <div style="opacity:.85;margin-bottom:6px">Valid: ${r.valid || ""} UTC</div>
        <div>Temp: <b>${r.tmpf || "—"}</b> °F</div>
        <div>Dew Pt: <b>${r.dwpf || "—"}</b> °F</div>
        <div>Wind: <b>${mph}</b> mph (gust <b>${gmh}</b>)</div>
        <div>Altimeter: <b>${r.alti || "—"}</b> inHg</div>
        <div>Alt trend (3h): <b>${dTxt}</b></div>
        <div>Vis: <b>${r.vsby || "—"}</b> mi</div>
        <div>Wx: <b>${(r.wxcodes || "").trim() || "—"}</b></div>
      </div>
    `;
  }

  async function fetchRows(d){
    const resp = await fetch(metarURL(d), { cache:"no-store" });
    if (!resp.ok) throw new Error(`METAR HTTP ${resp.status}`);
    return parseCSV(await resp.text());
  }

  async function refreshMetars(){
    statusEl.textContent = "Loading METARs…";

    const prev = new Date(current.getTime() - stepHours*3600*1000);
    const [rowsNow, rowsPrev] = await Promise.all([fetchRows(current), fetchRows(prev)]);

    // Map previous altimeter by station
    const prevAlt = new Map();
    for (const r of rowsPrev){
      const st = (r.station || "").trim();
      const a = num(r.alti);
      if (st && a != null) prevAlt.set(st, a);
    }

    // Clear clusters
    [tempCluster, dewCluster, windCluster, gustCluster, visCluster, presCluster, wxCluster].forEach(c => c.clearLayers());

    let added = 0;
    const MAX_POINTS = 2500;

    for (const r of rowsNow){
      if (added >= MAX_POINTS) break;

      const lat = num(r.lat), lon = num(r.lon);
      if (lat == null || lon == null) continue;

      const tmpf = num(r.tmpf);
      const dwpf = num(r.dwpf);
      const sknt = num(r.sknt);
      const gust = num(r.gust);
      const vsby = num(r.vsby);
      const alti = num(r.alti);
      const wx   = (r.wxcodes || "").trim();

      const st = (r.station || "").trim();
      const prevA = st ? prevAlt.get(st) : null;
      const dAlt = (alti != null && prevA != null) ? (alti - prevA) : null;

      if (tmpf != null){
        L.marker([lat,lon], { icon: dotIcon(Math.round(tmpf), tempColorF(tmpf)) })
          .bindPopup(popupHTML(r, dAlt)).addTo(tempCluster);
      }
      if (dwpf != null){
        L.marker([lat,lon], { icon: dotIcon(Math.round(dwpf), dewColorF(dwpf)) })
          .bindPopup(popupHTML(r, dAlt)).addTo(dewCluster);
      }

      // Wind circles (mph, colored like particles)
      if (sknt != null){
        const mph = ktToMph(sknt);
        L.marker([lat,lon], { icon: dotIcon(Math.round(mph), windColorMph(mph)) })
          .bindPopup(popupHTML(r, dAlt)).addTo(windCluster);
      }
      if (gust != null){
        const gmh = ktToMph(gust);
        L.marker([lat,lon], { icon: dotIcon(Math.round(gmh), windColorMph(gmh)) })
          .bindPopup(popupHTML(r, dAlt)).addTo(gustCluster);
      }

      if (vsby != null){
        L.marker([lat,lon], { icon: dotIcon(Math.round(vsby), "rgb(255,255,255)") })
          .bindPopup(popupHTML(r, dAlt)).addTo(visCluster);
      }

      // Pressure: show alti*100 as integer (fits), color by trend
      if (alti != null){
        const p100 = Math.round(alti * 100); // 29.92 -> 2992
        const fill = pressureTrendColor(dAlt);
        L.marker([lat,lon], { icon: dotIcon(String(p100), fill) })
          .bindPopup(popupHTML(r, dAlt)).addTo(presCluster);
      }

      if (wx){
        L.marker([lat,lon], { icon: dotIcon(wx, "rgb(255,255,255)") })
          .bindPopup(popupHTML(r, dAlt)).addTo(wxCluster);
      }

      added++;
    }

    statusEl.textContent = `Plotted ${added} stations (clustered).`;
  }

  // -----------------------------
  // Wind particles (daily mean for now)
  // -----------------------------
  const windParticlesUrl = "./wind_particles_20180414.json";

  async function loadParticles(){
    statusEl.textContent = "Loading wind particles…";
    const r = await fetch(windParticlesUrl, { cache:"no-store" });
    if (!r.ok) throw new Error(`Particles JSON HTTP ${r.status}`);
    const velData = await r.json();

    particlesLayer = L.velocityLayer({
      data: velData,
      velocityScale: 0.004,
      particleAge: 120,
      particleMultiplier: 1/800,
      lineWidth: 1.7,
      colorScale: [
        "rgb(0,40,160)",
        "rgb(0,120,255)",
        "rgb(0,210,180)",
        "rgb(255,220,0)",
        "rgb(255,120,0)"
      ],
      minVelocity: 0,
      maxVelocity: 60,
      displayValues: true,
      displayOptions: {
        velocityType: "Wind",
        position: "bottomleft",
        emptyString: "No wind data",
        angleConvention: "bearingCW",
        speedUnit: "mph"
      }
    });

    layerControl.addOverlay(particlesLayer, "Wind particles");
  }

  // -----------------------------
  // Alerts (WWA) – stub for now
  // -----------------------------
  async function loadAlertsForTime(){
    // Next step: call IEM watchwarn service for a time window and convert to GeoJSON for Leaflet.
    // IEM supports archived WWAs downloads via request/gis/watchwarn. :contentReference[oaicite:3]{index=3}
    alertsLayer.clearLayers();
  }

  // -----------------------------
  // Start
  // -----------------------------
  (async () => {
    try{
      await loadParticles();
      await refreshMetars();
      // loadAlertsForTime(); // we’ll wire this up next
      statusEl.textContent = "Ready. Use layer checkboxes.";
    } catch(e){
      console.error(e);
      statusEl.textContent = `Error: ${e.message}`;
    }
  })();
</script>
</body>
</html>
