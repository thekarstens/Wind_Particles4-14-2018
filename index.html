<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Apr 2018 Case Study – METAR + Wind Arrows + Daily Particles + Alerts</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Local Leaflet in your repo -->
<link rel="stylesheet" href="./leaflet.css"/>
<script src="./leaflet.js"></script>

<!-- Leaflet Velocity (WORKING CDN) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@2.1.4/dist/leaflet-velocity.css"/>
<script src="https://unpkg.com/leaflet-velocity@2.1.4/dist/leaflet-velocity.js"></script>

<style>
  html, body { height:100%; margin:0; }
  #map { height:100%; background:#fff; }

  .panel{
    position:absolute; top:10px; left:10px; z-index:9999;
    background:rgba(255,255,255,0.95);
    border:1px solid #ccc; border-radius:12px;
    padding:10px;
    font:600 12px/1.2 Arial, sans-serif;
    box-shadow: 0 2px 10px rgba(0,0,0,.10);
    min-width: 330px;
  }
  .row{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
  .btn{
    border:1px solid #333; background:#fff; border-radius:10px;
    padding:6px 10px; cursor:pointer; font:700 12px Arial;
  }
  .btn:active{ transform: translateY(1px); }
  .mono{ font-family: ui-monospace, Menlo, Consolas, monospace; font-weight:800; }

  .dot{
    border-radius:50%;
    border:2px solid #333;
    display:flex;align-items:center;justify-content:center;
    font:800 12px/1 Arial, sans-serif;color:#111;
    box-shadow: 0 1px 3px rgba(0,0,0,.25);
    user-select:none;
  }

  .swatch {
    display:inline-block;
    width:12px; height:12px;
    border:1px solid #333;
    border-radius:2px;
    vertical-align:middle;
    margin-right:6px;
  }

  .tiny {
    font:600 11px/1.2 Arial, sans-serif;
    opacity:.78;
  }
</style>
</head>

<body>
<div id="map"></div>

<div class="panel">
  <div style="font-size:13px;margin-bottom:6px">Apr 2018 Case Study</div>

  <!-- Time controls for METAR + Alerts -->
  <div class="row">
    <button class="btn" id="backBtn">◀ Time</button>
    <div class="mono" id="timeLabel">2018-04-14 15Z</div>
    <button class="btn" id="fwdBtn">Time ▶</button>
  </div>

  <!-- Day controls for PARTICLES ONLY -->
  <div class="row">
    <span class="tiny">Particles day:</span>
    <button class="btn" id="dayBackBtn">◀ Apr 13</button>
    <div class="mono" id="dayLabel">Apr 14</div>
    <button class="btn" id="dayFwdBtn">Apr 15 ▶</button>
  </div>

  <div class="row">
    <span style="opacity:.75">Step:</span>
    <span class="mono">3 hours</span>
    <span style="opacity:.75;margin-left:auto">Zoom:</span>
    <span class="mono" id="zoomLabel">6</span>
  </div>

  <div class="row">
    <span class="tiny" id="status">Loading…</span>
  </div>

  <div class="tiny">
    Wind arrows: direction wind is blowing <b>TO</b> (METAR direction + 180°).
  </div>
</div>

<script>
/* ------------------------------------------------------------
   1) Map
------------------------------------------------------------ */
const map = L.map("map", { zoomControl:true }).setView([44.2, -96.5], 6);

const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 19,
  attribution: "© OpenStreetMap contributors"
}).addTo(map);

// remove Leaflet prefix (keeps only OSM attribution)
map.attributionControl.setPrefix(false);

const statusEl    = document.getElementById("status");
const timeLabelEl = document.getElementById("timeLabel");
const dayLabelEl  = document.getElementById("dayLabel");
const zoomLabelEl = document.getElementById("zoomLabel");

function setStatus(msg){ statusEl.textContent = msg; }

map.on("zoomend", ()=>zoomLabelEl.textContent = String(map.getZoom()));
zoomLabelEl.textContent = String(map.getZoom());

/* ------------------------------------------------------------
   2) Time controls (METAR + Alerts)
------------------------------------------------------------ */
let current = new Date(Date.UTC(2018, 3, 14, 15, 0, 0)); // 2018-04-14 15Z
const stepHours = 3;

function fmtZ(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `${Y}-${M}-${D} ${H}Z`;
}
function toISOZ(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `${Y}-${M}-${D}T${H}:00:00Z`;
}
function updateTimeLabel(){ timeLabelEl.textContent = fmtZ(current); }
updateTimeLabel();

document.getElementById("backBtn").onclick = async () => {
  current = new Date(current.getTime() - stepHours*3600*1000);
  updateTimeLabel();
  await refreshAll();
};
document.getElementById("fwdBtn").onclick = async () => {
  current = new Date(current.getTime() + stepHours*3600*1000);
  updateTimeLabel();
  await refreshAll();
};

/* ------------------------------------------------------------
   3) Day controls (Particles only: Apr 13/14/15)
------------------------------------------------------------ */
let particleDay = 14; // 13, 14, 15
function updateDayLabel(){
  dayLabelEl.textContent = (particleDay === 13) ? "Apr 13" : (particleDay === 15) ? "Apr 15" : "Apr 14";
}
updateDayLabel();

document.getElementById("dayBackBtn").onclick = async () => {
  particleDay = Math.max(13, particleDay - 1);
  updateDayLabel();
  await refreshParticlesIfOn();
};
document.getElementById("dayFwdBtn").onclick = async () => {
  particleDay = Math.min(15, particleDay + 1);
  updateDayLabel();
  await refreshParticlesIfOn();
};

/* ------------------------------------------------------------
   4) Layers
------------------------------------------------------------ */
const tempLayer = L.layerGroup().addTo(map);
const dewLayer  = L.layerGroup();
const windNumLayer = L.layerGroup();
const windArrowLayer = L.layerGroup();
const gustLayer = L.layerGroup();
const visLayer  = L.layerGroup();
const presLayer = L.layerGroup();
const wxLayer   = L.layerGroup();

// Alerts
const alertsLayer = L.geoJSON(null);

// Particles: placeholder for checkbox + actual velocity layer
const particlesToggle = L.layerGroup();
let particlesLayer = null;

L.control.layers(
  { "OpenStreetMap": osm },
  {
    "Temperature (°F)": tempLayer,
    "Dew Point (°F)": dewLayer,
    "Wind Speed (mph)": windNumLayer,
    "Wind Arrows": windArrowLayer,
    "Wind Gusts (mph)": gustLayer,
    "Visibility (mi)": visLayer,
    "Pressure (trend)": presLayer,
    "Weather Codes": wxLayer,
    "Alerts (WWA)": alertsLayer,
    "Daily wind particles": particlesToggle
  },
  { collapsed:false }
).addTo(map);

/* ------------------------------------------------------------
   5) Collision thinning (drop stations if overlapping)
------------------------------------------------------------ */
class CollisionIndex {
  constructor(cellSizePx){
    this.cell = cellSizePx;
    this.grid = new Map();
  }
  _key(cx, cy){ return `${cx},${cy}`; }
  _cellOf(p){ return [Math.floor(p.x / this.cell), Math.floor(p.y / this.cell)]; }
  canPlace(p, minSepPx){
    const [cx, cy] = this._cellOf(p);
    const r2 = minSepPx * minSepPx;
    for (let dx=-1; dx<=1; dx++){
      for (let dy=-1; dy<=1; dy++){
        const key = this._key(cx+dx, cy+dy);
        const arr = this.grid.get(key);
        if (!arr) continue;
        for (const q of arr){
          const ddx = p.x - q.x;
          const ddy = p.y - q.y;
          if ((ddx*ddx + ddy*ddy) < r2) return false;
        }
      }
    }
    const key = this._key(cx, cy);
    if (!this.grid.has(key)) this.grid.set(key, []);
    this.grid.get(key).push({x:p.x, y:p.y});
    return true;
  }
}

function minSepForZoom(z){
  if (z <= 4) return 54;
  if (z === 5) return 46;
  if (z === 6) return 38;
  if (z === 7) return 32;
  return 0; // z >= 8 show all
}
function allowByCollision(index, lat, lon, minSepPx){
  if (minSepPx <= 0) return true;
  const p = map.latLngToLayerPoint([lat, lon]);
  return index.canPlace(p, minSepPx);
}

/* ------------------------------------------------------------
   6) Color ramps
------------------------------------------------------------ */
function piecewiseColor(x, stops){
  if (x == null || !Number.isFinite(x)) return "rgb(255,255,255)";
  if (x <= stops[0].v) return `rgb(${stops[0].c.join(",")})`;
  if (x >= stops[stops.length-1].v) return `rgb(${stops[stops.length-1].c.join(",")})`;
  for (let i=0; i<stops.length-1; i++){
    const a = stops[i], b = stops[i+1];
    if (x >= a.v && x <= b.v){
      const k = (x - a.v) / (b.v - a.v);
      const r = Math.round(a.c[0] + (b.c[0]-a.c[0]) * k);
      const g = Math.round(a.c[1] + (b.c[1]-a.c[1]) * k);
      const bb= Math.round(a.c[2] + (b.c[2]-a.c[2]) * k);
      return `rgb(${r},${g},${bb})`;
    }
  }
  return "rgb(255,255,255)";
}

function tempColorF(t){
  return piecewiseColor(t, [
    {v: 10, c: [170, 220, 255]},
    {v: 20, c: [120, 190, 255]},
    {v: 30, c: [0, 70, 200]},
    {v: 40, c: [0, 170, 0]},
    {v: 50, c: [150, 255, 150]},
    {v: 60, c: [255, 235, 0]},
    {v: 70, c: [255, 140, 0]},
    {v: 85, c: [255, 80, 0]}
  ]);
}

function dewColorF(td){
  return piecewiseColor(td, [
    {v: 10, c: [90, 55, 20]},
    {v: 20, c: [140, 95, 40]},
    {v: 30, c: [200, 160, 110]},
    {v: 50, c: [190, 200, 140]},
    {v: 60, c: [0, 170, 0]},
    {v: 70, c: [0, 90, 0]}
  ]);
}

function windColorMph(spd){
  return piecewiseColor(spd, [
    {v: 0,  c: [0, 40, 160]},
    {v: 10, c: [0, 120, 255]},
    {v: 20, c: [0, 210, 180]},
    {v: 35, c: [255, 220, 0]},
    {v: 50, c: [255, 120, 0]},
    {v: 70, c: [255, 80, 0]}
  ]);
}

function pressureTrendColor(deltaInHg){
  if (deltaInHg == null || !Number.isFinite(deltaInHg)) return "rgb(248,248,248)";
  if (deltaInHg > 0.02)  return "rgb(215,245,215)";
  if (deltaInHg < -0.02) return "rgb(255,220,220)";
  return "rgb(240,240,240)";
}

function visStyle(vis){
  if (vis == null || !Number.isFinite(vis)) {
    return { bg:"rgba(255,255,255,0.65)", border:"#333" };
  }
  const v = Math.max(0, Math.min(10, vis));
  const alpha = 1 - (v / 10);
  const border = (v < 1) ? "#666" : "#333";
  return { bg:`rgba(255,255,255,${alpha.toFixed(3)})`, border };
}

/* ------------------------------------------------------------
   7) Icons
------------------------------------------------------------ */
function dotIcon(txt, fill, size=28, fontSize=12, borderColor="#333"){
  return L.divIcon({
    className:"",
    html:`<div class="dot"
              style="width:${size}px;height:${size}px;
                     background:${fill};
                     border-color:${borderColor};
                     font-size:${fontSize}px;">${txt}</div>`,
    iconSize:[size,size],
    iconAnchor:[size/2,size/2]
  });
}

/* Wind arrow as inline SVG divIcon */
function windArrowIcon(bearingDeg, mph){
  // bearingDeg: direction wind is blowing TO
  const spd = (mph == null || !Number.isFinite(mph)) ? 0 : mph;
  const color = windColorMph(spd);

  // length scaling (px)
  const Lmin = 14, Lmax = 52;
  const len = Math.max(Lmin, Math.min(Lmax, Lmin + spd * 0.65));

  const w = 60, h = 60;
  const cx = w/2, cy = h/2;

  // Draw arrow pointing up (0 deg), then rotate container
  const svg = `
    <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
      <g transform="translate(${cx},${cy})">
        <line x1="0" y1="${len/2}" x2="0" y2="${-len/2}" stroke="${color}" stroke-width="4" stroke-linecap="round"/>
        <polygon points="0,${-len/2-8} -8,${-len/2+6} 8,${-len/2+6}" fill="${color}"/>
      </g>
    </svg>
  `;

  return L.divIcon({
    className:"",
    html:`<div style="width:${w}px;height:${h}px;transform:rotate(${bearingDeg}deg);">
            ${svg}
          </div>`,
    iconSize:[w,h],
    iconAnchor:[w/2,h/2]
  });
}

/* ------------------------------------------------------------
   8) Helpers
------------------------------------------------------------ */
function num(v){
  const s = (v ?? "").toString().trim();
  if (!s) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}
function ktToMph(kt){ return kt == null ? null : (kt * 1.15078); }

/* visibility parsing (fractions) */
function parseVisMiles(raw){
  if (raw == null) return { miles:null, label:"" };
  let s = String(raw).trim();
  if (!s) return { miles:null, label:"" };

  if (s.startsWith("M")) s = s.slice(1);
  s = s.replace(/\s+/g, " ");

  const n = Number(s);
  if (Number.isFinite(n)) return { miles:n, label:formatVisLabel(n) };

  const parts = s.split(" ");
  let whole = 0;
  let frac = null;

  if (parts.length === 2){
    whole = Number(parts[0]);
    frac = parts[1];
  } else {
    frac = parts[0];
  }

  if (frac && frac.includes("/")){
    const [a,b] = frac.split("/").map(Number);
    if (Number.isFinite(a) && Number.isFinite(b) && b !== 0){
      const val = (Number.isFinite(whole) ? whole : 0) + (a/b);
      return { miles:val, label:formatVisLabel(val) };
    }
  }
  return { miles:null, label:String(raw).trim() };
}
function formatVisLabel(x){
  if (!Number.isFinite(x)) return "";
  if (x >= 10) return "10+";

  const denom = 8;
  const whole = Math.floor(x);
  const frac = x - whole;
  const nume = Math.round(frac * denom);

  if (nume === 0) return String(whole);
  if (nume === denom) return String(whole + 1);

  const gcd = (a,b)=>b?gcd(b,a%b):a;
  const g = gcd(nume, denom);
  const n = nume / g;
  const d = denom / g;

  if (whole === 0) return `${n}/${d}`;
  return `${whole} ${n}/${d}`;
}

function popupHTML(r, dAlt){
  const tmp = num(r.tmpf);
  const dew = num(r.dwpf);
  const drct = num(r.drct);
  const sknt = num(r.sknt);
  const gust = num(r.gust);
  const alti = num(r.alti);

  const mph  = sknt != null ? Math.round(ktToMph(sknt)) : "—";
  const gmh  = gust != null ? Math.round(ktToMph(gust)) : "—";
  const altTxt = alti != null ? alti.toFixed(2) : "—";
  const dTxt = (dAlt == null) ? "—" : `${dAlt > 0 ? "+" : ""}${dAlt.toFixed(2)} in/3h`;

  const visObj = parseVisMiles(r.vsby);
  const visTxt = (visObj.label || r.vsby || "—");

  const toDir = (drct != null) ? ((drct + 180) % 360) : null;

  return `
    <div style="font:600 13px/1.3 Arial,sans-serif">
      <div style="font-size:14px;margin-bottom:4px"><b>${r.station || "Station"}</b></div>
      <div style="opacity:.85;margin-bottom:6px">Valid: ${r.valid || ""} UTC</div>
      <div>Temp: <b>${tmp == null ? "—" : Math.round(tmp)}</b> °F</div>
      <div>Dew Pt: <b>${dew == null ? "—" : Math.round(dew)}</b> °F</div>
      <div>Wind: <b>${mph}</b> mph (gust <b>${gmh}</b>)</div>
      <div>Wind dir (FROM): <b>${drct == null ? "—" : drct.toFixed(0)}°</b></div>
      <div>Arrow points (TO): <b>${toDir == null ? "—" : toDir.toFixed(0)}°</b></div>
      <div>Vis: <b>${visTxt}</b> mi</div>
      <div>Altimeter: <b>${altTxt}</b> inHg</div>
      <div>Alt trend (3h): <b>${dTxt}</b></div>
      <div>Wx: <b>${(r.wxcodes || "").trim() || "—"}</b></div>
    </div>
  `;
}

/* ------------------------------------------------------------
   9) METAR fetch
------------------------------------------------------------ */
const reportType = 3;
const SD_ONLY = ["SD_ASOS"];
const REST = ["MN_ASOS","IA_ASOS","NE_ASOS","ND_ASOS","WI_ASOS","IL_ASOS","MI_ASOS"];

function asosURL(d, networks){
  const iso = toISOZ(d);
  return "https://mesonet.agron.iastate.edu/cgi-bin/request/asos.py"
    + "?data=tmpf&data=dwpf&data=drct&data=sknt&data=gust&data=vsby&data=alti&data=wxcodes"
    + `&network=${encodeURIComponent(networks.join(","))}`
    + `&report_type=${reportType}`
    + "&latlon=yes&format=onlycomma&tz=UTC"
    + `&sts=${encodeURIComponent(iso)}`
    + `&ets=${encodeURIComponent(iso)}`
    + "&missing=empty";
}

function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim() && !l.startsWith("#"));
  if (lines.length < 2) return [];
  const header = lines[0].split(",");
  return lines.slice(1).map(line => {
    const cols = line.split(",");
    const obj = {};
    header.forEach((h,i)=>obj[h]=cols[i] ?? "");
    return obj;
  });
}

async function fetchRows(d, networks){
  const resp = await fetch(asosURL(d, networks), { cache:"no-store" });
  if (!resp.ok) throw new Error(`METAR HTTP ${resp.status}`);
  return parseCSV(await resp.text());
}

/* ------------------------------------------------------------
   10) Alerts styling (best effort)
------------------------------------------------------------ */
const NWS_EVENT_COLOR = {
  "Blizzard Warning": "#FF4500",
  "Winter Storm Warning": "#FF69B4",
  "Winter Storm Watch": "#4682B4",
  "Winter Weather Advisory": "#7B68EE",
  "Ice Storm Warning": "#8B008B",
  "Snow Squall Warning": "#C71585",
  "High Wind Warning": "#DAA520",
  "Wind Advisory": "#D2B48C",
  "Dense Fog Advisory": "#708090"
};

function pickProp(p, keys){
  if (!p) return "";
  for (const k of keys){
    if (p[k] != null && String(p[k]).trim() !== "") return String(p[k]).trim();
    const kk = Object.keys(p).find(x => x.toLowerCase() === k.toLowerCase());
    if (kk && p[kk] != null && String(p[kk]).trim() !== "") return String(p[kk]).trim();
  }
  return "";
}

function eventNameFromProps(p){
  const e = pickProp(p, ["event","headline","name","title"]);
  if (e) return e;

  const phen = pickProp(p, ["phenomena","phenom","PHENOM","phen"]);
  const sig  = pickProp(p, ["significance","sig","SIG"]);
  if (phen && sig){
    // Map common winter keys to friendly names
    const key = `${phen}.${sig}`.toUpperCase();
    if (key === "BZ.W") return "Blizzard Warning";
    if (key === "WS.W") return "Winter Storm Warning";
    if (key === "WS.A") return "Winter Storm Watch";
    if (key === "WW.Y") return "Winter Weather Advisory";
    return key;
  }
  // Some files only have WFO/ETN/STATUS (not enough to know hazard)
  const wfo = pickProp(p, ["WFO","wfo"]);
  const etn = pickProp(p, ["ETN","etn"]);
  return (wfo || etn) ? `Alert ${wfo || ""} ${etn || ""}`.trim() : "Alert";
}

function colorForAlertName(name){
  if (NWS_EVENT_COLOR[name]) return NWS_EVENT_COLOR[name];
  const lower = String(name).toLowerCase();
  if (lower.includes("blizzard") && lower.includes("warning")) return NWS_EVENT_COLOR["Blizzard Warning"];
  if (lower.includes("winter storm") && lower.includes("warning")) return NWS_EVENT_COLOR["Winter Storm Warning"];
  if (lower.includes("winter storm") && lower.includes("watch")) return NWS_EVENT_COLOR["Winter Storm Watch"];
  if (lower.includes("winter weather") && lower.includes("advisory")) return NWS_EVENT_COLOR["Winter Weather Advisory"];
  // fallback
  return "#CC0000";
}

function alertsFileNameForTime(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `./alerts_${Y}-${M}-${D}T${H}Z.geojson`;
}

async function loadAlerts(){
  if (!map.hasLayer(alertsLayer)) return;

  const url = alertsFileNameForTime(current);
  try{
    const r = await fetch(url, { cache:"no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const gj = await r.json();

    alertsLayer.clearLayers();

    L.geoJSON(gj, {
      style: (feat) => {
        const p = feat.properties || {};
        const name = eventNameFromProps(p);
        const c = colorForAlertName(name);
        return { weight:2, color:c, fillColor:c, fillOpacity:0.18 };
      },
      onEachFeature: (feat, layer) => {
        const p = feat.properties || {};
        const name = eventNameFromProps(p);
        const c = colorForAlertName(name);

        // student-friendly summary
        const wfo = pickProp(p, ["WFO","wfo"]);
        const etn = pickProp(p, ["ETN","etn"]);
        const status = pickProp(p, ["STATUS","status"]);
        const issued = pickProp(p, ["issuance","issued","onset","ISSUANCE","ISSUED"]);
        const expire = pickProp(p, ["expire","expires","end","EXPIRE","EXPIRES"]);

        const lines = [];
        lines.push(`<div><span class="swatch" style="background:${c}"></span><b>${name}</b></div>`);
        if (wfo || etn) lines.push(`Office/Event: <b>${wfo || "—"}</b> / <b>${etn || "—"}</b>`);
        if (status) lines.push(`Status: <b>${status}</b>`);
        if (issued) lines.push(`Issued: <b>${issued}</b>`);
        if (expire) lines.push(`Expires: <b>${expire}</b>`);

        // If your file lacks hazard type, tell you in popup (student-friendly)
        const hasHazard = !!pickProp(p, ["event","phenomena","phenom","PHENOM","significance","sig","SIG"]);
        if (!hasHazard){
          lines.push(`<div style="margin-top:6px;opacity:.75">
            Note: this alert file doesn’t include hazard type (Blizzard/WSW/etc), so colors may be limited.
          </div>`);
        }

        layer.bindPopup(lines.join("<br>"));
      }
    }).eachLayer(l => alertsLayer.addLayer(l));

  } catch(e){
    console.warn("Alerts load failed:", url, e.message);
    alertsLayer.clearLayers();
  }
}

/* ------------------------------------------------------------
   11) Daily particles (toggle + day buttons)
------------------------------------------------------------ */
function particlesFileForDay(dayNum){
  // Expect these in your repo root:
  // wind_particles_20180413.json
  // wind_particles_20180414.json
  // wind_particles_20180415.json
  return `./wind_particles_201804${String(dayNum).padStart(2,"0")}.json`;
}

function normalizeVelocityJson(raw){
  if (Array.isArray(raw)) return raw;
  if (raw && Array.isArray(raw.data)) return raw.data;
  return raw;
}

async function refreshParticlesIfOn(){
  if (!map.hasLayer(particlesToggle)) return;

  if (typeof L.velocityLayer !== "function"){
    setStatus("Wind particles: leaflet-velocity did not load.");
    return;
  }

  const url = particlesFileForDay(particleDay);

  try{
    const r = await fetch(url, { cache:"no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const raw = await r.json();
    const velData = normalizeVelocityJson(raw);

    if (particlesLayer){
      try { map.removeLayer(particlesLayer); } catch(_) {}
      particlesLayer = null;
    }

    particlesLayer = L.velocityLayer({
      data: velData,
      velocityScale: 0.004,
      particleAge: 120,
      particleMultiplier: 1/900,
      lineWidth: 1.7,
      colorScale: [
        "rgb(0,40,160)",
        "rgb(0,120,255)",
        "rgb(0,210,180)",
        "rgb(255,220,0)",
        "rgb(255,120,0)"
      ],
      minVelocity: 0,
      maxVelocity: 60,
      displayValues: false
    });

    particlesLayer.addTo(map);
    setStatus(`Particles loaded: ${url.replace("./","")}`);

  } catch(e){
    console.warn("Particles failed:", url, e.message);
    setStatus(`Particles not found: ${url.replace("./","")}`);
  }
}

/* Toggle handlers for particles */
map.on("overlayadd", async (e) => {
  if (e.layer === particlesToggle) await refreshParticlesIfOn();
  if (e.layer === alertsLayer) await loadAlerts();
});
map.on("overlayremove", (e) => {
  if (e.layer === particlesToggle && particlesLayer){
    map.removeLayer(particlesLayer);
    particlesLayer = null;
  }
});

/* ------------------------------------------------------------
   12) Main refresh (METAR + alerts + arrows)
------------------------------------------------------------ */
async function refreshAll(){
  setStatus("Loading METARs…");

  const prev = new Date(current.getTime() - stepHours*3600*1000);

  const [sdNow, restNow, sdPrev, restPrev] = await Promise.all([
    fetchRows(current, SD_ONLY),
    fetchRows(current, REST),
    fetchRows(prev, SD_ONLY),
    fetchRows(prev, REST)
  ]);

  const rowsNow  = sdNow.concat(restNow);
  const rowsPrev = sdPrev.concat(restPrev);

  // previous altimeter for pressure trend
  const prevAlt = new Map();
  for (const r of rowsPrev){
    const st = (r.station || "").trim();
    const a  = num(r.alti);
    if (st && a != null) prevAlt.set(st, a);
  }

  // Clear layers
  [tempLayer, dewLayer, windNumLayer, windArrowLayer, gustLayer, visLayer, presLayer, wxLayer].forEach(l => l.clearLayers());

  const z = map.getZoom();
  const minSep = minSepForZoom(z);

  const idxTemp = new CollisionIndex(Math.max(24, minSep));
  const idxDew  = new CollisionIndex(Math.max(24, minSep));
  const idxWind = new CollisionIndex(Math.max(24, minSep));
  const idxGust = new CollisionIndex(Math.max(24, minSep));
  const idxVis  = new CollisionIndex(Math.max(24, minSep));
  const idxPres = new CollisionIndex(Math.max(24, minSep));
  const idxWx   = new CollisionIndex(Math.max(24, minSep));
  const idxArr  = new CollisionIndex(Math.max(30, minSep));

  let shown = 0, total = 0;

  for (const r of rowsNow){
    const lat = num(r.lat), lon = num(r.lon);
    if (lat == null || lon == null) continue;
    total++;

    // Collision-thinning gate per layer (lets you keep “SD dense” feel while still preventing clutter)
    const st = (r.station || "").trim();
    const alti = num(r.alti);
    const prevA = st ? prevAlt.get(st) : null;
    const dAlt = (alti != null && prevA != null) ? (alti - prevA) : null;

    const popup = popupHTML(r, dAlt);

    const tmp = num(r.tmpf);
    const dew = num(r.dwpf);

    const drct = num(r.drct);
    const sknt = num(r.sknt);
    const gust = num(r.gust);

    const mph  = sknt != null ? ktToMph(sknt) : null;
    const gmh  = gust != null ? ktToMph(gust) : null;

    const visObj = parseVisMiles(r.vsby);
    const visMi = visObj.miles;

    // Temp
    if (tmp != null && allowByCollision(idxTemp, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(String(Math.round(tmp)), tempColorF(tmp), 28, 12) })
        .bindPopup(popup).addTo(tempLayer);
    }

    // Dew
    if (dew != null && allowByCollision(idxDew, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(String(Math.round(dew)), dewColorF(dew), 28, 12) })
        .bindPopup(popup).addTo(dewLayer);
    }

    // Wind numbers
    if (mph != null && allowByCollision(idxWind, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(String(Math.round(mph)), windColorMph(mph), 28, 12) })
        .bindPopup(popup).addTo(windNumLayer);
    }

    // Wind arrows (direction + speed scaling)
    if (mph != null && drct != null && allowByCollision(idxArr, lat, lon, minSep)){
      const toDir = (drct + 180) % 360; // arrow points TO
      L.marker([lat,lon], { icon: windArrowIcon(toDir, mph) })
        .bindPopup(popup).addTo(windArrowLayer);
    }

    // Gusts
    if (gmh != null && allowByCollision(idxGust, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(String(Math.round(gmh)), windColorMph(gmh), 30, 12) })
        .bindPopup(popup).addTo(gustLayer);
    }

    // Visibility
    if ((visObj.label || "").trim() && allowByCollision(idxVis, lat, lon, minSep)){
      const style = visStyle(visMi);
      L.marker([lat,lon], { icon: dotIcon(visObj.label, style.bg, 30, 11, style.border) })
        .bindPopup(popup).addTo(visLayer);
    }

    // Pressure
    if (alti != null && allowByCollision(idxPres, lat, lon, minSep)){
      const fill = pressureTrendColor(dAlt);
      L.marker([lat,lon], { icon: dotIcon(alti.toFixed(2), fill, 44, 12, "#999") })
        .bindPopup(popup).addTo(presLayer);
    }

    // Weather codes
    const wx = (r.wxcodes || "").trim();
    if (wx && allowByCollision(idxWx, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(wx, "rgba(255,255,255,0.85)", 30, 10, "#999") })
        .bindPopup(popup).addTo(wxLayer);
    }

    shown++;
  }

  setStatus(`Stations shown: ${shown}/${total} (minSep ${minSep}px).`);

  await loadAlerts();
}

/* Initial render */
refreshAll().catch(err => {
  console.error(err);
  setStatus("Error: " + err.message);
});
</script>
</body>
</html>
