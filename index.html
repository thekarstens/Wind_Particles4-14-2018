bash -lc cat > /mnt/data/index.html <<'HTML'
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Apr 14, 2018 Case Study – METAR Layers + Wind Particles + Alerts</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Local Leaflet (your repo copies) -->
<link rel="stylesheet" href="./leaflet.css"/>
<script src="./leaflet.js"></script>

<!-- Leaflet-Velocity (CDN so it won't 404 on GitHub Pages) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@2.1.4/dist/leaflet-velocity.css"/>
<script src="https://unpkg.com/leaflet-velocity@2.1.4/dist/leaflet-velocity.js"></script>

<style>
  html, body { height:100%; margin:0; }
  #map { height:100%; background:#fff; }

  .panel{
    position:absolute; top:10px; left:10px; z-index:9999;
    background:rgba(255,255,255,0.95);
    border:1px solid #ccc; border-radius:12px;
    padding:10px;
    font:600 12px/1.2 Arial, sans-serif;
    box-shadow: 0 2px 10px rgba(0,0,0,.10);
    min-width: 300px;
  }
  .row{ display:flex; gap:8px; align-items:center; margin-top:8px; }
  .btn{
    border:1px solid #333; background:#fff; border-radius:10px;
    padding:6px 10px; cursor:pointer; font:700 12px Arial;
  }
  .btn:active{ transform: translateY(1px); }
  .mono{ font-family: ui-monospace, Menlo, Consolas, monospace; font-weight:800; }

  .dot{
    border-radius:50%;
    border:2px solid #333;
    display:flex;align-items:center;justify-content:center;
    font:800 12px/1 Arial, sans-serif;color:#111;
    box-shadow: 0 1px 3px rgba(0,0,0,.25);
    user-select:none;
  }

  /* Tiny legend box used inside alert popups */
  .legendRow{ display:flex; align-items:center; gap:8px; margin:4px 0; }
  .swatch{ width:14px;height:14px;border-radius:3px;border:1px solid #333; display:inline-block; }
</style>
</head>

<body>
<div id="map"></div>

<div class="panel">
  <div style="font-size:13px;margin-bottom:6px">Apr 14, 2018 Case Study</div>

  <div class="row">
    <button class="btn" id="backBtn">◀ Back</button>
    <div class="mono" id="timeLabel">2018-04-14 15Z</div>
    <button class="btn" id="fwdBtn">Forward ▶</button>
  </div>

  <div class="row">
    <span style="opacity:.75">Step:</span>
    <span class="mono" id="stepLabel">3 hours</span>
    <span style="opacity:.75;margin-left:auto">Zoom:</span>
    <span class="mono" id="zoomLabel">6</span>
  </div>

  <div class="row">
    <span style="opacity:.75" id="status">Loading…</span>
  </div>
</div>

<script>
// ============================================================
// 0) Helpers
// ============================================================
const statusEl    = document.getElementById("status");
const timeLabelEl = document.getElementById("timeLabel");
const zoomLabelEl = document.getElementById("zoomLabel");
function setStatus(msg){ statusEl.textContent = msg; }

function num(v){
  const s = (v ?? "").toString().trim();
  if (!s) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function fmtZ(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `${Y}-${M}-${D} ${H}Z`;
}

function stampForFiles(d){
  // wind_particles_2018-04-14T15Z.json
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `${Y}-${M}-${D}T${H}Z`;
}

function toISOZ(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `${Y}-${M}-${D}T${H}:00:00Z`;
}

function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim() && !l.startsWith("#"));
  if (lines.length < 2) return [];
  const header = lines[0].split(",");
  const rows = [];
  for (let i=1; i<lines.length; i++){
    const cols = lines[i].split(",");
    const obj = {};
    header.forEach((h, idx) => obj[h] = cols[idx] ?? "");
    rows.push(obj);
  }
  return rows;
}

// ============================================================
// 1) Map
// ============================================================
const map = L.map("map", { zoomControl:true }).setView([44.2, -96.5], 6);
const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 19,
  attribution: "© OpenStreetMap contributors"
}).addTo(map);
map.attributionControl.setPrefix(false);

map.on("zoomend", () => {
  zoomLabelEl.textContent = String(map.getZoom());
});
zoomLabelEl.textContent = String(map.getZoom());

// ============================================================
// 2) Time controls (Option A: 3-hour steps + per-time particle JSON)
// ============================================================
let current = new Date(Date.UTC(2018, 3, 14, 15, 0, 0)); // 2018-04-14 15Z
const stepHours = 3;

function updateTimeLabel(){ timeLabelEl.textContent = fmtZ(current); }
updateTimeLabel();

document.getElementById("backBtn").addEventListener("click", () => {
  current = new Date(current.getTime() - stepHours*3600*1000);
  updateTimeLabel();
  refreshAll();
});

document.getElementById("fwdBtn").addEventListener("click", () => {
  current = new Date(current.getTime() + stepHours*3600*1000);
  updateTimeLabel();
  refreshAll();
});

// ============================================================
// 3) Layers
// ============================================================
const tempLayer = L.layerGroup().addTo(map);
const dewLayer  = L.layerGroup();
const windLayer = L.layerGroup();
const gustLayer = L.layerGroup();
const visLayer  = L.layerGroup();
const presLayer = L.layerGroup();
const wxLayer   = L.layerGroup();

// Alerts layer
const alertsLayer = L.geoJSON(null, {
  style: (feat) => alertStyle(feat),
  onEachFeature: (feat, layer) => alertPopup(feat, layer)
});

// Wind particles layer (Leaflet-Velocity)
let particlesLayer = null;
let particlesEnabled = false;

const overlays = {
  "Temperature (°F)": tempLayer,
  "Dew Point (°F)": dewLayer,
  "Wind (mph)": windLayer,
  "Wind Gusts (mph)": gustLayer,
  "Visibility (mi)": visLayer,
  "Pressure": presLayer,
  "Weather Codes": wxLayer,
  "Alerts (WWA)": alertsLayer,
  "Wind particles": L.layerGroup() // placeholder so checkbox exists
};

const layerControl = L.control.layers({"OpenStreetMap": osm}, overlays, {collapsed:false}).addTo(map);

// Detect when user toggles "Wind particles" checkbox
map.on("overlayadd", (e) => {
  if (e.name === "Wind particles"){
    particlesEnabled = true;
    loadParticlesForTime().catch(()=>{});
  }
});
map.on("overlayremove", (e) => {
  if (e.name === "Wind particles"){
    particlesEnabled = false;
    if (particlesLayer){ map.removeLayer(particlesLayer); particlesLayer = null; }
  }
});

// ============================================================
// 4) METAR fetch (IEM ASOS)
// ============================================================
function metarURLForTime(){
  // Keep this simple: use many ASOS networks to cover the Midwest box
  // (You can add more networks if you want)
  const iso = toISOZ(current);
  const url =
    "https://mesonet.agron.iastate.edu/cgi-bin/request/asos.py"
    + "?data=tmpf&data=dwpf&data=drct&data=sknt&data=gust&data=vsby&data=alti&data=wxcodes"
    + "&network=SD_ASOS,MN_ASOS,IA_ASOS,NE_ASOS,ND_ASOS,WI_ASOS,IL_ASOS,KS_ASOS"
    + "&report_type=3"
    + "&latlon=yes&format=onlycomma&tz=UTC"
    + `&sts=${encodeURIComponent(iso)}`
    + `&ets=${encodeURIComponent(iso)}`
    + "&missing=empty";
  return url;
}

// Color ramps you asked for earlier (simple discrete steps)
function tempColorF(t){
  if (t == null) return "#ffffff";
  if (t < 30) return "#9fd3ff";     // 10s/20s light blue
  if (t < 40) return "#1f5fbf";     // 30s dark blue
  if (t < 50) return "#2ebd59";     // 40s green
  if (t < 60) return "#a7f3a7";     // 50s light green
  if (t < 70) return "#ffe15a";     // 60s yellow
  return "#ff9a2e";                 // 70s+ orange
}

function dewColorF(td){
  if (td == null) return "#ffffff";
  if (td < 20) return "#5a3a10";    // dark brown
  if (td < 40) return "#caa26a";    // light brown
  if (td < 60) return "#7acb7a";    // light green
  return "#0d7a2a";                 // dark green 60/70+
}

function dotIcon(txt, fill){
  const size = 28;
  return L.divIcon({
    className: "",
    html: `<div class="dot" style="width:${size}px;height:${size}px;background:${fill}">${txt}</div>`,
    iconSize: [size,size],
    iconAnchor: [size/2,size/2]
  });
}

function fracVisText(v){
  // Keep it simple: show common fractions nicely when close
  if (v == null) return "—";
  const x = Number(v);
  const fracs = [
    [0.125, "1/8"],
    [0.25, "1/4"],
    [0.5, "1/2"],
    [0.75, "3/4"],
    [1.0, "1"],
    [1.5, "1 1/2"],
    [2.0, "2"],
    [3.0, "3"],
    [5.0, "5"],
    [10.0, "10"],
  ];
  for (const [val, lab] of fracs){
    if (Math.abs(x - val) < 0.06) return lab;
  }
  return (x % 1 === 0) ? String(x.toFixed(0)) : String(x.toFixed(1));
}

function visColor(v){
  // white near 0, open circle when clear
  if (v == null) return {fill:"#ffffff", opacity:0.65};
  const x = Number(v);
  if (x >= 10) return {fill:"#ffffff", opacity:0.0};
  // map 0..10 -> 0.85..0.15
  const op = 0.85 - (Math.min(Math.max(x,0),10)/10)*0.70;
  return {fill:"#ffffff", opacity: op};
}

function popupHTML(r){
  const id = r.station || "";
  const v  = r.valid || "";
  const tmpf = num(r.tmpf);
  const dwpf = num(r.dwpf);
  const drct = num(r.drct);
  const sknt = num(r.sknt);
  const gust = num(r.gust);
  const vsby = num(r.vsby);
  const alti = num(r.alti);
  const wx   = (r.wxcodes || "").trim();

  const mph = (sknt == null) ? null : Math.round(sknt * 1.15078);
  const gmh = (gust == null) ? null : Math.round(gust * 1.15078);

  return `
    <div style="font:600 13px/1.3 Arial,sans-serif">
      <div style="font-size:14px;margin-bottom:4px"><b>${id}</b></div>
      <div style="opacity:.85;margin-bottom:6px">Valid: ${v} UTC</div>
      <div>Temp: <b>${tmpf == null ? "—" : Math.round(tmpf)}</b> °F</div>
      <div>Dew Pt: <b>${dwpf == null ? "—" : Math.round(dwpf)}</b> °F</div>
      <div>Wind: <b>${drct == null ? "—" : Math.round(drct)}</b>° @ <b>${mph == null ? "—" : mph}</b> mph ${gmh != null ? `(gust ${gmh})` : ``}</div>
      <div>Vis: <b>${vsby == null ? "—" : fracVisText(vsby)}</b> mi</div>
      <div>Altimeter: <b>${alti == null ? "—" : alti.toFixed(2)}</b> inHg</div>
      <div>Wx: <b>${wx || "—"}</b></div>
    </div>
  `;
}

function drawMETAR(rows){
  [tempLayer, dewLayer, windLayer, gustLayer, visLayer, presLayer, wxLayer].forEach(l => l.clearLayers());

  // Simple overlap thinning: keep points at least N pixels apart for each layer.
  // (This avoids full clustering and keeps the map readable when zoomed out.)
  const minSepPx = Math.max(24, 44 - map.getZoom()*2); // zoom 6=>32-ish

  function makeKeeper(){
    const kept = [];
    return (latlng) => {
      const p = map.latLngToLayerPoint(latlng);
      for (const kp of kept){
        const dx = p.x - kp.x;
        const dy = p.y - kp.y;
        if (dx*dx + dy*dy < minSepPx*minSepPx) return false;
      }
      kept.push(p);
      return true;
    };
  }

  const keepTemp = makeKeeper();
  const keepDew  = makeKeeper();
  const keepWind = makeKeeper();
  const keepGust = makeKeeper();
  const keepVis  = makeKeeper();
  const keepPres = makeKeeper();
  const keepWx   = makeKeeper();

  let plotted = 0;
  for (const r of rows){
    const lat = num(r.lat);
    const lon = num(r.lon);
    if (lat == null || lon == null) continue;
    const ll = L.latLng(lat, lon);

    const tmpf = num(r.tmpf);
    const dwpf = num(r.dwpf);
    const drct = num(r.drct);
    const sknt = num(r.sknt);
    const gust = num(r.gust);
    const vsby = num(r.vsby);
    const alti = num(r.alti);
    const wx   = (r.wxcodes || "").trim();

    // Temperature / Dew point
    if (tmpf != null && keepTemp(ll)){
      L.marker(ll, {icon: dotIcon(String(Math.round(tmpf)), tempColorF(tmpf))})
        .bindPopup(popupHTML(r))
        .addTo(tempLayer);
      plotted++;
    }
    if (dwpf != null && keepDew(ll)){
      L.marker(ll, {icon: dotIcon(String(Math.round(dwpf)), dewColorF(dwpf))})
        .bindPopup(popupHTML(r))
        .addTo(dewLayer);
    }

    // Wind & gust (mph in colored circles matching particle colors later)
    if ((sknt != null || gust != null) && keepWind(ll)){
      const mph = sknt == null ? null : Math.round(sknt*1.15078);
      if (mph != null){
        L.marker(ll, {icon: dotIcon(String(mph), "#ffffff")})
          .bindPopup(popupHTML(r))
          .addTo(windLayer);
      }
    }
    if (gust != null && keepGust(ll)){
      const gmh = Math.round(gust*1.15078);
      L.marker(ll, {icon: dotIcon(String(gmh), "#ffffff")})
        .bindPopup(popupHTML(r))
        .addTo(gustLayer);
    }

    // Visibility (fractions, fade)
    if (vsby != null && keepVis(ll)){
      const vtxt = fracVisText(vsby);
      const vc = visColor(vsby);
      const size = 30;
      const html = `<div class="dot" style="width:${size}px;height:${size}px;background:${vc.fill};opacity:${vc.opacity}">${vtxt}</div>`;
      const icon = L.divIcon({className:"", html, iconSize:[size,size], iconAnchor:[size/2,size/2]});
      L.marker(ll, {icon}).bindPopup(popupHTML(r)).addTo(visLayer);
    }

    // Pressure: show altimeter with one decimal, bigger circle, light color
    if (alti != null && keepPres(ll)){
      const txt = (alti*10).toFixed(1); // keep one decimal, slightly compact
      const size = 34;
      const html = `<div class="dot" style="width:${size}px;height:${size}px;background:#f5f0ff">${txt}</div>`;
      const icon = L.divIcon({className:"", html, iconSize:[size,size], iconAnchor:[size/2,size/2]});
      L.marker(ll, {icon}).bindPopup(popupHTML(r)).addTo(presLayer);
    }

    // Wx codes (small circle)
    if (wx && keepWx(ll)){
      const size = 34;
      const html = `<div class="dot" style="width:${size}px;height:${size}px;background:#fff3d6;font-size:11px">${wx}</div>`;
      const icon = L.divIcon({className:"", html, iconSize:[size,size], iconAnchor:[size/2,size/2]});
      L.marker(ll, {icon}).bindPopup(popupHTML(r)).addTo(wxLayer);
    }
  }

  setStatus(`METARs drawn (thinned, zoom ${map.getZoom()}).`);
}

async function loadMETAR(){
  const url = metarURLForTime();
  const resp = await fetch(url, {cache:"no-store"});
  if (!resp.ok) throw new Error(`METAR HTTP ${resp.status}`);
  const text = await resp.text();
  const rows = parseCSV(text);
  drawMETAR(rows);
}

// ============================================================
// 5) Alerts (your files exist, but your screenshot shows they only contain WFO/ETN/STATUS)
//    To color by NWS hazard type, the GeoJSON MUST include PHENOM + SIG (or equivalent).
//    This code supports both cases:
//      - If PHENOM/SIG present -> NWS-ish colors
//      - If missing -> neutral gray + popup explains what's missing
// ============================================================

// Simple NWS-ish colors for your winter set (easy to extend)
const ALERT_COLORS = {
  "BZ.W": "#FF4500", // Blizzard Warning
  "WS.W": "#FF69B4", // Winter Storm Warning
  "WS.A": "#4682B4", // Winter Storm Watch
  "WW.Y": "#7B68EE", // Winter Weather Advisory
};
const ALERT_NAMES = {
  "BZ.W": "Blizzard Warning",
  "WS.W": "Winter Storm Warning",
  "WS.A": "Winter Storm Watch",
  "WW.Y": "Winter Weather Advisory",
};

function pickProp(p, keys){
  for (const k of keys){
    if (p && p[k] != null && String(p[k]).trim() !== "") return String(p[k]).trim();
  }
  return "";
}

function alertKeyFromProps(p){
  // Try a bunch of likely field names
  const ps = pickProp(p, ["ps", "PS"]); // some IEM feeds include this
  if (ps && ps.includes(".")) return ps;

  const ph = pickProp(p, ["phenomena", "PHENOMENA", "PHENOM", "phenom", "PHEN"]);
  const sg = pickProp(p, ["significance", "SIGNIFICANCE", "SIG", "sig"]);
  if (ph && sg) return `${ph}.${sg}`;

  // Last resort: if you have an EVENT name, we can map later
  return "";
}

function alertColorFor(p){
  const k = alertKeyFromProps(p);
  if (k && ALERT_COLORS[k]) return ALERT_COLORS[k];
  return "#777777"; // neutral when unknown
}

function alertNameFor(p){
  const k = alertKeyFromProps(p);
  if (k && ALERT_NAMES[k]) return ALERT_NAMES[k];
  return k || "NWS Alert";
}

function alertStyle(feat){
  const p = (feat && feat.properties) ? feat.properties : {};
  const k = alertKeyFromProps(p);
  const c = alertColorFor(p);

  if (!k){
    // Unknown hazard type: use dashed outline so it doesn't look "wrong"
    return { color: c, weight: 2, dashArray: "5,4", fillColor: c, fillOpacity: 0.08 };
  }

  return { color: c, weight: 2, fillColor: c, fillOpacity: 0.18 };
}

function alertPopup(feat, layer){
  const p = (feat && feat.properties) ? feat.properties : {};
  const k = alertKeyFromProps(p);
  const name = alertNameFor(p);
  const c = alertColorFor(p);

  const wfo = pickProp(p, ["wfo", "WFO"]);
  const etn = pickProp(p, ["etn", "ETN", "eventid", "EVENTID"]);
  const status = pickProp(p, ["status", "STATUS"]);

  const extraMsg = (!k)
    ? `<div style="margin-top:8px;opacity:.85">
         <b>Note:</b> This alert GeoJSON file is missing PHENOM/SIG (hazard type),
         so it can't be colored by Blizzard/WS/etc yet. If you regenerate alerts with
         PHENOM and SIG fields, the colors will apply automatically.
       </div>`
    : "";

  layer.bindPopup(`
    <div style="font:600 13px/1.3 Arial,sans-serif">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
        <span class="swatch" style="background:${c}"></span>
        <div style="font-size:14px"><b>${name}</b></div>
      </div>
      <div class="legendRow"><span style="opacity:.85">Code:</span> <b>${k || "—"}</b></div>
      <div class="legendRow"><span style="opacity:.85">WFO:</span> <b>${wfo || "—"}</b></div>
      <div class="legendRow"><span style="opacity:.85">ETN:</span> <b>${etn || "—"}</b></div>
      ${status ? `<div class="legendRow"><span style="opacity:.85">Status:</span> <b>${status}</b></div>` : ``}
      ${extraMsg}
    </div>
  `);
}

function alertsFilenameForTime(){
  // Your repo files are like alerts_2018-04-14T15Z.geojson
  return `./alerts_${stampForFiles(current)}.geojson`;
}

async function loadAlerts(){
  const url = alertsFilenameForTime();
  const resp = await fetch(url, {cache:"no-store"});
  if (!resp.ok) throw new Error(`Alerts missing: ${url} (HTTP ${resp.status})`);
  const gj = await resp.json();
  alertsLayer.clearLayers();
  alertsLayer.addData(gj);
}

// ============================================================
// 6) Wind particles (Option A)
//    Looks for per-time file first:
//      wind_particles_2018-04-14T15Z.json
//    Falls back to your daily file:
//      wind_particles_20180414.json
// ============================================================

function particlesFilenameForTime(){
  return `./wind_particles_${stampForFiles(current)}.json`;
}

async function fetchJSON(url){
  const resp = await fetch(url, {cache:"no-store"});
  if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
  return await resp.json();
}

function buildParticlesLayer(data){
  // If the plugin didn't load, fail cleanly
  if (typeof L.velocityLayer !== "function"){
    throw new Error("Leaflet-Velocity not loaded (L.velocityLayer missing)");
  }

  // A few conservative settings so it stays readable for grades 5–8
  return L.velocityLayer({
    data: data,
    displayValues: false,
    displayOptions: {
      velocityType: "Wind",
      position: "bottomleft",
      emptyString: "No wind"
    },
    maxVelocity: 60,
    velocityScale: 0.008,
    particleAge: 40,
    lineWidth: 2
  });
}

async function loadParticlesForTime(){
  if (!particlesEnabled) return;

  const perTime = particlesFilenameForTime();
  const daily = "./wind_particles_20180414.json";

  setStatus("Loading wind particles…");

  let data = null;
  try {
    data = await fetchJSON(perTime);
  } catch (e) {
    console.warn("Particles time file missing, falling back:", perTime, e);
    data = await fetchJSON(daily);
  }

  // Replace layer
  if (particlesLayer){ map.removeLayer(particlesLayer); particlesLayer = null; }
  particlesLayer = buildParticlesLayer(data);
  particlesLayer.addTo(map);
  setStatus("Wind particles loaded.");
}

// ============================================================
// 7) Master refresh
// ============================================================
async function refreshAll(){
  const z = map.getZoom();
  zoomLabelEl.textContent = String(z);

  try {
    setStatus("Loading METARs…");
    await loadMETAR();
  } catch (e) {
    console.error(e);
    setStatus(`METAR error: ${e.message}`);
  }

  try {
    await loadAlerts();
  } catch (e) {
    console.warn(e);
    // Don't overwrite a METAR error; just append hint
    if (!statusEl.textContent.startsWith("METAR error")){
      setStatus("METARs loaded. Alerts missing for this hour (check filename).");
    }
  }

  try {
    await loadParticlesForTime();
  } catch (e) {
    console.error(e);
    // leave METAR/alert status if already set; just log
  }
}

// Initial load
refreshAll();

// If you pan/zoom, redraw METAR thinning for current time (fast + looks better)
let redrawTimer = null;
map.on("moveend", () => {
  if (redrawTimer) clearTimeout(redrawTimer);
  redrawTimer = setTimeout(() => refreshAll(), 150);
});

</script>
</body>
</html>
HTML
