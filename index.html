<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Apr 14, 2018 Case Study – METAR Layers + Wind Particles + Alerts</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Your local Leaflet files (already in repo root) -->
<link rel="stylesheet" href="./leaflet.css"/>
<script src="./leaflet.js"></script>

<!-- ✅ FIX: Leaflet-Velocity from a working CDN (no local files needed) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@2.1.4/dist/leaflet-velocity.css"/>
<script src="https://unpkg.com/leaflet-velocity@2.1.4/dist/leaflet-velocity.js"></script>

<style>
  html, body { height:100%; margin:0; }
  #map { height:100%; background:#fff; }

  .panel{
    position:absolute; top:10px; left:10px; z-index:9999;
    background:rgba(255,255,255,0.95);
    border:1px solid #ccc; border-radius:12px;
    padding:10px;
    font:600 12px/1.2 Arial, sans-serif;
    box-shadow: 0 2px 10px rgba(0,0,0,.10);
    min-width: 290px;
  }
  .row{ display:flex; gap:8px; align-items:center; margin-top:8px; }
  .btn{
    border:1px solid #333; background:#fff; border-radius:10px;
    padding:6px 10px; cursor:pointer; font:700 12px Arial;
  }
  .btn:active{ transform: translateY(1px); }
  .mono{ font-family: ui-monospace, Menlo, Consolas, monospace; font-weight:800; }

  .dot{
    border-radius:50%;
    border:2px solid #333;
    display:flex;align-items:center;justify-content:center;
    font:800 12px/1 Arial, sans-serif;color:#111;
    box-shadow: 0 1px 3px rgba(0,0,0,.25);
    user-select:none;
  }

  .swatch {
    display:inline-block;
    width:12px; height:12px;
    border:1px solid #333;
    border-radius:2px;
    vertical-align:middle;
    margin-right:6px;
  }
</style>
</head>

<body>
<div id="map"></div>

<div class="panel">
  <div style="font-size:13px;margin-bottom:6px">Apr 14, 2018 Case Study</div>

  <div class="row">
    <button class="btn" id="backBtn">◀ Back</button>
    <div class="mono" id="timeLabel">2018-04-14 15Z</div>
    <button class="btn" id="fwdBtn">Forward ▶</button>
  </div>

  <div class="row">
    <span style="opacity:.75">METAR step:</span>
    <span class="mono">3 hours</span>
    <span style="opacity:.75;margin-left:auto">Zoom:</span>
    <span class="mono" id="zoomLabel">6</span>
  </div>

  <div class="row">
    <span style="opacity:.75" id="status">Loading…</span>
  </div>
</div>

<script>
  // ------------------------------------------------------------
  // 1) Map
  // ------------------------------------------------------------
  const map = L.map("map", { zoomControl:true }).setView([44.2, -96.5], 6);

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "© OpenStreetMap contributors"
  }).addTo(map);

  // Optional: remove Leaflet prefix in attribution (keeps only OSM attribution)
  map.attributionControl.setPrefix(false);

  const statusEl    = document.getElementById("status");
  const timeLabelEl = document.getElementById("timeLabel");
  const zoomLabelEl = document.getElementById("zoomLabel");

  function setStatus(msg){ statusEl.textContent = msg; }

  // ------------------------------------------------------------
  // 2) Time controls (OPTION 1)
  //    Start time matches your alerts files: 03Z,06Z,...,21Z
  //    So we start at 15Z (15 -> 18 -> 21 -> 00 next day)
  // ------------------------------------------------------------
  let current = new Date(Date.UTC(2018, 3, 14, 15, 0, 0)); // OPTION 1
  const stepHours = 3;

  function fmtZ(d){
    const Y = d.getUTCFullYear();
    const M = String(d.getUTCMonth()+1).padStart(2,"0");
    const D = String(d.getUTCDate()).padStart(2,"0");
    const H = String(d.getUTCHours()).padStart(2,"0");
    return `${Y}-${M}-${D} ${H}Z`;
  }
  function toISOZ(d){
    const Y = d.getUTCFullYear();
    const M = String(d.getUTCMonth()+1).padStart(2,"0");
    const D = String(d.getUTCDate()).padStart(2,"0");
    const H = String(d.getUTCHours()).padStart(2,"0");
    return `${Y}-${M}-${D}T${H}:00:00Z`;
  }
  function updateTimeLabel(){ timeLabelEl.textContent = fmtZ(current); }
  updateTimeLabel();

  document.getElementById("backBtn").onclick = async () => {
    current = new Date(current.getTime() - stepHours*3600*1000);
    updateTimeLabel();
    await refreshIfNeeded();
  };
  document.getElementById("fwdBtn").onclick = async () => {
    current = new Date(current.getTime() + stepHours*3600*1000);
    updateTimeLabel();
    await refreshIfNeeded();
  };

  // ------------------------------------------------------------
  // 3) Overlay layers
  // ------------------------------------------------------------
  const tempLayer = L.layerGroup().addTo(map);
  const dewLayer  = L.layerGroup();
  const windLayer = L.layerGroup();
  const gustLayer = L.layerGroup();
  const visLayer  = L.layerGroup();
  const presLayer = L.layerGroup();
  const wxLayer   = L.layerGroup();

  // ------------------------------------------------------------
  // 3b) Alerts colors (NWS Hazards Map hex colors)
  // Source: NWS Hazards Map color list. (We map common ones you need.)
  // ------------------------------------------------------------
  const NWS_EVENT_COLOR = {
    "Blizzard Warning": "#FF4500",            // Orangered
    "Winter Storm Warning": "#FF69B4",        // Hotpink
    "Winter Storm Watch": "#4682B4",          // Steelblue (commonly used on NWS maps)
    "Winter Weather Advisory": "#7B68EE",     // Mediumslateblue (commonly used)
    "Ice Storm Warning": "#8B008B",           // Darkmagenta
    "Snow Squall Warning": "#C71585",         // Mediumvioletred
    "Wind Advisory": "#D2B48C",               // Tan (often)
    "High Wind Warning": "#DAA520",           // Goldenrod (NWS list)
    "Dense Fog Advisory": "#708090"           // Slategray (often)
  };

  function pickProp(p, keys){
    for (const k of keys){
      if (p && p[k] != null && String(p[k]).trim() !== "") return p[k];
      // try case-insensitive match
      const kk = Object.keys(p || {}).find(x => x.toLowerCase() === k.toLowerCase());
      if (kk && p[kk] != null && String(p[kk]).trim() !== "") return p[kk];
    }
    return "";
  }

  function alertEventName(p){
    // Prefer explicit "event"
    const event = String(pickProp(p, ["event","headline","product","name","title"])).trim();
    if (event) return event;

    // Otherwise build from phenomena/significance if present
    const phen = String(pickProp(p, ["phenomena","phenom","ph"])).trim();
    const sig  = String(pickProp(p, ["significance","sig"])).trim();

    // Some datasets have VTEC-like PHEN/SIG pairs; try to translate a couple common ones
    // (If we can’t, we’ll show phen.sig)
    const vtec = (phen && sig) ? `${phen}.${sig}` : phen || sig || "Alert";
    return vtec;
  }

  function alertColorForFeature(feat){
    const p = (feat && feat.properties) ? feat.properties : {};
    const name = alertEventName(p);

    // Exact match on common event names
    if (NWS_EVENT_COLOR[name]) return NWS_EVENT_COLOR[name];

    // Loose matching (helps if event name includes extra words)
    const lower = String(name).toLowerCase();
    if (lower.includes("blizzard") && lower.includes("warning")) return NWS_EVENT_COLOR["Blizzard Warning"];
    if (lower.includes("winter storm") && lower.includes("warning")) return NWS_EVENT_COLOR["Winter Storm Warning"];
    if (lower.includes("winter storm") && lower.includes("watch"))   return NWS_EVENT_COLOR["Winter Storm Watch"];
    if (lower.includes("winter weather") && lower.includes("advisory")) return NWS_EVENT_COLOR["Winter Weather Advisory"];
    if (lower.includes("ice storm") && lower.includes("warning")) return NWS_EVENT_COLOR["Ice Storm Warning"];
    if (lower.includes("snow squall") && lower.includes("warning")) return NWS_EVENT_COLOR["Snow Squall Warning"];
    if (lower.includes("high wind") && lower.includes("warning")) return NWS_EVENT_COLOR["High Wind Warning"];

    // Fallback: a neutral red outline (but not full red fill)
    return "#CC0000";
  }

  // Alerts (GeoJSON files hosted in repo)
  const alertsLayer = L.geoJSON(null, {
    style: (feat) => {
      const c = alertColorForFeature(feat);
      return { weight: 2, color: c, fillColor: c, fillOpacity: 0.18 };
    },
    onEachFeature: (feat, layer) => {
      const p = feat.properties || {};
      const event = alertEventName(p);
      const c = alertColorForFeature(feat);

      const wfo      = String(pickProp(p, ["wfo","office","issuer"])).trim();
      const status   = String(pickProp(p, ["status"])).trim();
      const issuance = String(pickProp(p, ["issuance","issued","issue","onset"])).trim();
      const expire   = String(pickProp(p, ["expire","expires","end","ends","expires_utc"])).trim();
      const url      = String(pickProp(p, ["uri","url","link"])).trim();

      const lines = [];
      lines.push(`<div><span class="swatch" style="background:${c}"></span><b>${event}</b></div>`);
      if (wfo) lines.push(`WFO: ${wfo}`);
      if (status) lines.push(`Status: ${status}`);
      if (issuance) lines.push(`Issued: ${issuance}`);
      if (expire) lines.push(`Expires: ${expire}`);
      if (url) lines.push(`<a href="${url}" target="_blank" rel="noopener">Open alert text</a>`);

      layer.bindPopup(lines.join("<br>") || "Alert");
    }
  });

  // Particles layer is added later to keep it optional
  let particlesLayer = null;

  const overlays = {
    "Temperature (°F)": tempLayer,
    "Dew Point (°F)": dewLayer,
    "Wind (mph)": windLayer,
    "Wind Gusts (mph)": gustLayer,
    "Visibility (mi)": visLayer,
    "Pressure (trend)": presLayer,
    "Weather Codes": wxLayer,
    "Alerts (WWA)": alertsLayer
  };

  const layerControl = L.control.layers(
    { "OpenStreetMap": osm },
    overlays,
    { collapsed:false }
  ).addTo(map);

  // ------------------------------------------------------------
  // 4) Collision thinning (spatial hash)
  //    Drops stations when circles would overlap/touch.
  // ------------------------------------------------------------
  class CollisionIndex {
    constructor(cellSizePx){
      this.cell = cellSizePx;
      this.grid = new Map();
    }
    _key(cx, cy){ return `${cx},${cy}`; }
    _cellOf(p){ return [Math.floor(p.x / this.cell), Math.floor(p.y / this.cell)]; }
    canPlace(p, minSepPx){
      const [cx, cy] = this._cellOf(p);
      const r2 = minSepPx * minSepPx;
      for (let dx=-1; dx<=1; dx++){
        for (let dy=-1; dy<=1; dy++){
          const key = this._key(cx+dx, cy+dy);
          const arr = this.grid.get(key);
          if (!arr) continue;
          for (const q of arr){
            const ddx = p.x - q.x;
            const ddy = p.y - q.y;
            if ((ddx*ddx + ddy*ddy) < r2) return false;
          }
        }
      }
      const key = this._key(cx, cy);
      if (!this.grid.has(key)) this.grid.set(key, []);
      this.grid.get(key).push({x:p.x, y:p.y});
      return true;
    }
  }

  function minSepForZoom(z){
    if (z <= 4) return 54;
    if (z === 5) return 46;
    if (z === 6) return 38;
    if (z === 7) return 32;
    return 0; // z >= 8 show all
  }

  function allowByCollision(index, lat, lon, minSepPx){
    if (minSepPx <= 0) return true;
    const p = map.latLngToLayerPoint([lat, lon]);
    return index.canPlace(p, minSepPx);
  }

  // ------------------------------------------------------------
  // 5) Color ramps
  // ------------------------------------------------------------
  function piecewiseColor(x, stops){
    if (x == null || !Number.isFinite(x)) return "rgb(255,255,255)";
    if (x <= stops[0].v) return `rgb(${stops[0].c.join(",")})`;
    if (x >= stops[stops.length-1].v) return `rgb(${stops[stops.length-1].c.join(",")})`;
    for (let i=0; i<stops.length-1; i++){
      const a = stops[i], b = stops[i+1];
      if (x >= a.v && x <= b.v){
        const k = (x - a.v) / (b.v - a.v);
        const r = Math.round(a.c[0] + (b.c[0]-a.c[0]) * k);
        const g = Math.round(a.c[1] + (b.c[1]-a.c[1]) * k);
        const bb= Math.round(a.c[2] + (b.c[2]-a.c[2]) * k);
        return `rgb(${r},${g},${bb})`;
      }
    }
    return "rgb(255,255,255)";
  }

  function tempColorF(t){
    return piecewiseColor(t, [
      {v: 10, c: [170, 220, 255]},
      {v: 20, c: [120, 190, 255]},
      {v: 30, c: [0, 70, 200]},
      {v: 40, c: [0, 170, 0]},
      {v: 50, c: [150, 255, 150]},
      {v: 60, c: [255, 235, 0]},
      {v: 70, c: [255, 140, 0]},
      {v: 85, c: [255, 80, 0]}
    ]);
  }

  function dewColorF(td){
    return piecewiseColor(td, [
      {v: 10, c: [90, 55, 20]},
      {v: 20, c: [140, 95, 40]},
      {v: 30, c: [200, 160, 110]},
      {v: 50, c: [190, 200, 140]},
      {v: 60, c: [0, 170, 0]},
      {v: 70, c: [0, 90, 0]}
    ]);
  }

  function windColorMph(spd){
    return piecewiseColor(spd, [
      {v: 0,  c: [0, 40, 160]},
      {v: 10, c: [0, 120, 255]},
      {v: 20, c: [0, 210, 180]},
      {v: 35, c: [255, 220, 0]},
      {v: 50, c: [255, 120, 0]},
      {v: 70, c: [255, 80, 0]}
    ]);
  }

  function pressureTrendColor(deltaInHg){
    if (deltaInHg == null || !Number.isFinite(deltaInHg)) return "rgb(248,248,248)";
    if (deltaInHg > 0.02)  return "rgb(215,245,215)";
    if (deltaInHg < -0.02) return "rgb(255,220,220)";
    return "rgb(240,240,240)";
  }

  function visStyle(vis){
    if (vis == null || !Number.isFinite(vis)) {
      return { bg:"rgba(255,255,255,0.65)", border:"#333" };
    }
    const v = Math.max(0, Math.min(10, vis));
    const alpha = 1 - (v / 10);
    const border = (v < 1) ? "#666" : "#333";
    return { bg:`rgba(255,255,255,${alpha.toFixed(3)})`, border };
  }

  // ------------------------------------------------------------
  // 6) Icons
  // ------------------------------------------------------------
  function dotIcon(txt, fill, size=28, fontSize=12, borderColor="#333"){
    return L.divIcon({
      className:"",
      html:`<div class="dot"
                style="width:${size}px;height:${size}px;
                       background:${fill};
                       border-color:${borderColor};
                       font-size:${fontSize}px;">${txt}</div>`,
      iconSize:[size,size],
      iconAnchor:[size/2,size/2]
    });
  }

  // ------------------------------------------------------------
  // 7) Parsing helpers
  // ------------------------------------------------------------
  function num(v){
    const s = (v ?? "").toString().trim();
    if (!s) return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }
  function ktToMph(kt){ return kt == null ? null : (kt * 1.15078); }

  function parseVisMiles(raw){
    if (raw == null) return { miles:null, label:"" };
    let s = String(raw).trim();
    if (!s) return { miles:null, label:"" };

    if (s.startsWith("M")) s = s.slice(1);
    s = s.replace(/\s+/g, " ");

    const n = Number(s);
    if (Number.isFinite(n)) return { miles:n, label:formatVisLabel(n) };

    const parts = s.split(" ");
    let whole = 0;
    let frac = null;

    if (parts.length === 2){
      whole = Number(parts[0]);
      frac = parts[1];
    } else {
      frac = parts[0];
    }

    if (frac && frac.includes("/")){
      const [a,b] = frac.split("/").map(Number);
      if (Number.isFinite(a) && Number.isFinite(b) && b !== 0){
        const val = (Number.isFinite(whole) ? whole : 0) + (a/b);
        return { miles:val, label:formatVisLabel(val) };
      }
    }

    return { miles:null, label:String(raw).trim() };
  }

  function formatVisLabel(x){
    if (!Number.isFinite(x)) return "";
    if (x >= 10) return "10+";

    const denom = 8;
    const whole = Math.floor(x);
    const frac = x - whole;
    const nume = Math.round(frac * denom);

    if (nume === 0) return String(whole);
    if (nume === denom) return String(whole + 1);

    const gcd = (a,b)=>b?gcd(b,a%b):a;
    const g = gcd(nume, denom);
    const n = nume / g;
    const d = denom / g;

    if (whole === 0) return `${n}/${d}`;
    return `${whole} ${n}/${d}`;
  }

  // ------------------------------------------------------------
  // 8) METAR fetch (SD first, then rest)
  // ------------------------------------------------------------
  const reportType = 3;
  const SD_ONLY = ["SD_ASOS"];
  const REST = ["MN_ASOS","IA_ASOS","NE_ASOS","ND_ASOS","WI_ASOS","IL_ASOS","MI_ASOS"];

  function asosURL(d, networks){
    const iso = toISOZ(d);
    return "https://mesonet.agron.iastate.edu/cgi-bin/request/asos.py"
      + "?data=tmpf&data=dwpf&data=sknt&data=gust&data=vsby&data=alti&data=wxcodes"
      + `&network=${encodeURIComponent(networks.join(","))}`
      + `&report_type=${reportType}`
      + "&latlon=yes&format=onlycomma&tz=UTC"
      + `&sts=${encodeURIComponent(iso)}`
      + `&ets=${encodeURIComponent(iso)}`
      + "&missing=empty";
  }

  function parseCSV(text){
    const lines = text.split(/\r?\n/).filter(l => l.trim() && !l.startsWith("#"));
    if (lines.length < 2) return [];
    const header = lines[0].split(",");
    return lines.slice(1).map(line => {
      const cols = line.split(",");
      const obj = {};
      header.forEach((h,i)=>obj[h]=cols[i] ?? "");
      return obj;
    });
  }

  async function fetchRows(d, networks){
    const resp = await fetch(asosURL(d, networks), { cache:"no-store" });
    if (!resp.ok) throw new Error(`METAR HTTP ${resp.status}`);
    return parseCSV(await resp.text());
  }

  function popupHTML(r, dAlt){
    const tmp = num(r.tmpf);
    const dew = num(r.dwpf);
    const sknt = num(r.sknt);
    const gust = num(r.gust);
    const alti = num(r.alti);

    const mph  = sknt != null ? Math.round(ktToMph(sknt)) : "—";
    const gmh  = gust != null ? Math.round(ktToMph(gust)) : "—";
    const altTxt = alti != null ? alti.toFixed(2) : "—";
    const dTxt = (dAlt == null) ? "—" : `${dAlt > 0 ? "+" : ""}${dAlt.toFixed(2)} in/3h`;

    const visObj = parseVisMiles(r.vsby);
    const visTxt = (visObj.label || r.vsby || "—");

    return `
      <div style="font:600 13px/1.3 Arial,sans-serif">
        <div style="font-size:14px;margin-bottom:4px"><b>${r.station || "Station"}</b></div>
        <div style="opacity:.85;margin-bottom:6px">Valid: ${r.valid || ""} UTC</div>
        <div>Temp: <b>${tmp == null ? "—" : Math.round(tmp)}</b> °F</div>
        <div>Dew Pt: <b>${dew == null ? "—" : Math.round(dew)}</b> °F</div>
        <div>Wind: <b>${mph}</b> mph (gust <b>${gmh}</b>)</div>
        <div>Vis: <b>${visTxt}</b> mi</div>
        <div>Altimeter: <b>${altTxt}</b> inHg</div>
        <div>Alt trend (3h): <b>${dTxt}</b></div>
        <div>Wx: <b>${(r.wxcodes || "").trim() || "—"}</b></div>
      </div>
    `;
  }

  function anyOverlayVisible(){
    return (
      map.hasLayer(tempLayer) ||
      map.hasLayer(dewLayer)  ||
      map.hasLayer(windLayer) ||
      map.hasLayer(gustLayer) ||
      map.hasLayer(visLayer)  ||
      map.hasLayer(presLayer) ||
      map.hasLayer(wxLayer)   ||
      map.hasLayer(alertsLayer) ||
      (particlesLayer && map.hasLayer(particlesLayer))
    );
  }

  async function refreshIfNeeded(){
    if (!anyOverlayVisible()) return;
    await refreshAll();
  }

  // ------------------------------------------------------------
  // 9) Alerts loader
  // ------------------------------------------------------------
  function alertsFileNameForTime(d){
    const Y = d.getUTCFullYear();
    const M = String(d.getUTCMonth()+1).padStart(2,"0");
    const D = String(d.getUTCDate()).padStart(2,"0");
    const H = String(d.getUTCHours()).padStart(2,"0");
    return `./alerts_${Y}-${M}-${D}T${H}Z.geojson`;
  }

  async function loadAlerts(){
    if (!map.hasLayer(alertsLayer)) return;
    const url = alertsFileNameForTime(current);

    try{
      const r = await fetch(url, { cache:"no-store" });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const gj = await r.json();
      alertsLayer.clearLayers();
      alertsLayer.addData(gj);
    } catch(e){
      console.warn("Alerts load failed:", url, e.message);
      alertsLayer.clearLayers();
    }
  }

  // ------------------------------------------------------------
  // 10) Main refresh
  // ------------------------------------------------------------
  async function refreshAll(){
    setStatus("Loading METARs…");

    const prev = new Date(current.getTime() - stepHours*3600*1000);

    const [sdNow, restNow, sdPrev, restPrev] = await Promise.all([
      fetchRows(current, SD_ONLY),
      fetchRows(current, REST),
      fetchRows(prev, SD_ONLY),
      fetchRows(prev, REST)
    ]);

    const rowsNow  = sdNow.concat(restNow);
    const rowsPrev = sdPrev.concat(restPrev);

    const prevAlt = new Map();
    for (const r of rowsPrev){
      const st = (r.station || "").trim();
      const a  = num(r.alti);
      if (st && a != null) prevAlt.set(st, a);
    }

    const visible = {
      temp: map.hasLayer(tempLayer),
      dew:  map.hasLayer(dewLayer),
      wind: map.hasLayer(windLayer),
      gust: map.hasLayer(gustLayer),
      vis:  map.hasLayer(visLayer),
      pres: map.hasLayer(presLayer),
      wx:   map.hasLayer(wxLayer)
    };

    if (visible.temp) tempLayer.clearLayers();
    if (visible.dew)  dewLayer.clearLayers();
    if (visible.wind) windLayer.clearLayers();
    if (visible.gust) gustLayer.clearLayers();
    if (visible.vis)  visLayer.clearLayers();
    if (visible.pres) presLayer.clearLayers();
    if (visible.wx)   wxLayer.clearLayers();

    const z = map.getZoom();
    zoomLabelEl.textContent = String(z);
    const minSep = minSepForZoom(z);

    const idxTemp = new CollisionIndex(Math.max(24, minSep));
    const idxDew  = new CollisionIndex(Math.max(24, minSep));
    const idxWind = new CollisionIndex(Math.max(24, minSep));
    const idxGust = new CollisionIndex(Math.max(24, minSep));
    const idxVis  = new CollisionIndex(Math.max(24, minSep));
    const idxPres = new CollisionIndex(Math.max(24, minSep));
    const idxWx   = new CollisionIndex(Math.max(24, minSep));

    const HARD_CAP = 4000;
    let scanned = 0;

    for (const r of rowsNow){
      if (scanned >= HARD_CAP) break;
      scanned++;

      const lat = num(r.lat), lon = num(r.lon);
      if (lat == null || lon == null) continue;

      const st = (r.station || "").trim();
      const alti = num(r.alti);
      const prevA = st ? prevAlt.get(st) : null;
      const dAlt = (alti != null && prevA != null) ? (alti - prevA) : null;

      if (visible.temp){
        const tmpf = num(r.tmpf);
        if (tmpf != null && allowByCollision(idxTemp, lat, lon, minSep)){
          L.marker([lat,lon], { icon: dotIcon(String(Math.round(tmpf)), tempColorF(tmpf), 28, 12) })
            .bindPopup(popupHTML(r, dAlt)).addTo(tempLayer);
        }
      }

      if (visible.dew){
        const dwpf = num(r.dwpf);
        if (dwpf != null && allowByCollision(idxDew, lat, lon, minSep)){
          L.marker([lat,lon], { icon: dotIcon(String(Math.round(dwpf)), dewColorF(dwpf), 28, 12) })
            .bindPopup(popupHTML(r, dAlt)).addTo(dewLayer);
        }
      }

      if (visible.wind){
        const sknt = num(r.sknt);
        if (sknt != null){
          const mph = ktToMph(sknt);
          if (allowByCollision(idxWind, lat, lon, minSep)){
            L.marker([lat,lon], { icon: dotIcon(String(Math.round(mph)), windColorMph(mph), 28, 12) })
              .bindPopup(popupHTML(r, dAlt)).addTo(windLayer);
          }
        }
      }

      if (visible.gust){
        const gust = num(r.gust);
        if (gust != null){
          const gmh = ktToMph(gust);
          if (allowByCollision(idxGust, lat, lon, minSep)){
            L.marker([lat,lon], { icon: dotIcon(String(Math.round(gmh)), windColorMph(gmh), 28, 12) })
              .bindPopup(popupHTML(r, dAlt)).addTo(gustLayer);
          }
        }
      }

      if (visible.vis){
        const visObj = parseVisMiles(r.vsby);
        const visMi = visObj.miles;
        const label = (visObj.label || (r.vsby ?? "").toString().trim());
        if (label && allowByCollision(idxVis, lat, lon, minSep)){
          const style = visStyle(visMi);
          L.marker([lat,lon], { icon: dotIcon(label, style.bg, 28, 11, style.border) })
            .bindPopup(popupHTML(r, dAlt)).addTo(visLayer);
        }
      }

      if (visible.pres && alti != null){
        const fill = pressureTrendColor(dAlt);
        const txt = alti.toFixed(2);
        const size = 44;
        const font = 12;
        const border = "#999";
        if (allowByCollision(idxPres, lat, lon, minSep)){
          L.marker([lat,lon], { icon: dotIcon(txt, fill, size, font, border) })
            .bindPopup(popupHTML(r, dAlt)).addTo(presLayer);
        }
      }

      if (visible.wx){
        const wx = (r.wxcodes || "").trim();
        if (wx && allowByCollision(idxWx, lat, lon, minSep)){
          L.marker([lat,lon], { icon: dotIcon(wx, "rgba(255,255,255,0.85)", 28, 10) })
            .bindPopup(popupHTML(r, dAlt)).addTo(wxLayer);
        }
      }
    }

    await loadAlerts();
    setStatus(`Overlap-thinning active (minSep ${minSep}px).`);
  }

  map.on("zoomend", async () => {
    zoomLabelEl.textContent = String(map.getZoom());
    await refreshIfNeeded();
  });
  map.on("overlayadd", async () => { await refreshIfNeeded(); });
  map.on("overlayremove", async () => { await refreshIfNeeded(); });

  // ------------------------------------------------------------
  // 11) Wind particles (daily file stays the same so we don’t break anything)
  // ------------------------------------------------------------
  const windParticlesUrl = "./wind_particles_20180414.json";

  function normalizeVelocityJson(raw){
    // Leaflet-velocity expects an array of records (u/v grids).
    // If your JSON is already correct, we return as-is.
    if (Array.isArray(raw)) return raw;
    if (raw && Array.isArray(raw.data)) return raw.data;
    return raw; // last resort
  }

  async function loadParticlesOnce(){
    setStatus("Loading wind particles…");
    const r = await fetch(windParticlesUrl, { cache:"no-store" });
    if (!r.ok) throw new Error(`Particles JSON HTTP ${r.status}`);
    const velRaw = await r.json();
    const velData = normalizeVelocityJson(velRaw);

    if (typeof L.velocityLayer !== "function"){
      throw new Error("Leaflet-velocity not loaded (L.velocityLayer missing). Check CDN.");
    }

    particlesLayer = L.velocityLayer({
      data: velData,
      velocityScale: 0.004,
      particleAge: 120,
      particleMultiplier: 1/800,
      lineWidth: 1.7,
      colorScale: [
        "rgb(0,40,160)",
        "rgb(0,120,255)",
        "rgb(0,210,180)",
        "rgb(255,220,0)",
        "rgb(255,120,0)"
      ],
      minVelocity: 0,
      maxVelocity: 60,
      displayValues: true,
      displayOptions: {
        velocityType: "Wind",
        position: "bottomleft",
        emptyString: "No wind data",
        angleConvention: "bearingCW",
        speedUnit: "mph"
      }
    });

    layerControl.addOverlay(particlesLayer, "Wind particles");
  }

  // ------------------------------------------------------------
  // 12) Start
  // ------------------------------------------------------------
  (async () => {
    try{
      zoomLabelEl.textContent = String(map.getZoom());
      await loadParticlesOnce();     // creates checkbox for particles
      await refreshIfNeeded();       // draws default layer(s)
      setStatus("Ready. Toggle layers; zoom in for more stations.");
    } catch(e){
      console.error(e);
      setStatus(`Error: ${e.message}`);
    }
  })();
</script>
</body>
</html>
